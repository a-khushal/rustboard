import { collaborationState } from '$lib/stores/collaboration';
import { get } from 'svelte/store';
import { tick } from 'svelte';
import { updateStores } from './editor-sync';
import { get as getStore } from 'svelte/store';
import { defaultStrokeWidth } from '$lib/stores/stroke-width';
import { defaultStrokeColor } from '$lib/stores/stroke-color';
import { renderTrigger } from '$lib/stores/editor';
// @ts-expect-error -- generated by wasm-bindgen
import type { EditorApi } from '../../../pkg/rustboard_wasm';

const WS_URL = import.meta.env.VITE_WS_URL || 'ws://localhost:3001';
const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001';

export interface Operation {
	op: string;
	[id: string]: any;
}

export interface ClientMessage {
	type: 'Join' | 'Update' | 'Presence' | 'Ping';
	client_id?: string;
	name?: string;
	color?: string;
	operation?: Operation;
	cursor?: { x: number; y: number } | null;
	selected_ids?: number[];
}

export interface ServerMessage {
	type: 'Joined' | 'ClientJoined' | 'ClientLeft' | 'Update' | 'Presence' | 'Error' | 'Pong';
	client_id?: string;
	clients?: Array<{ id: string; name: string; color: string }>;
	document?: string;
	operation?: Operation;
	client?: { id: string; name: string; color: string };
	seq?: number;
	source_local_id?: number;
	cursor?: { x: number; y: number } | null;
	selected_ids?: number[];
	message?: string;
}

export interface SessionInfo {
	session_id: string;
	editor_token: string;
	viewer_token: string;
	editor_url: string;
	viewer_url: string;
}

let ws: WebSocket | null = null;
let reconnectTimeout: NodeJS.Timeout | null = null;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_DELAY = 1000;
let operationQueue: Operation[] = [];
let lastAppliedSeq = 0;
const pendingUpdates = new Map<number, { operation: Operation; client_id: string; source_local_id?: number }>();
const localToServerId = new Map<number, number>();
const serverToLocalId = new Map<number, number>();
let pendingPresencePayload: { cursor: { x: number; y: number } | null; selected_ids: number[] } | null = null;
let lastPresenceSentAt = 0;
let lastPresenceSignature = '';
const PRESENCE_THROTTLE_MS = 50;

function resetRealtimeSyncState() {
	lastAppliedSeq = 0;
	pendingUpdates.clear();
	localToServerId.clear();
	serverToLocalId.clear();
	pendingPresencePayload = null;
	lastPresenceSentAt = 0;
	lastPresenceSignature = '';
}

function registerIdMapping(localId: number, serverId: number) {
	localToServerId.set(localId, serverId);
	serverToLocalId.set(serverId, localId);
}

function resolveOutgoingId(id: number): number {
	return localToServerId.get(id) ?? id;
}

function resolveIncomingId(id: number): number {
	return serverToLocalId.get(id) ?? id;
}

function cloneOperation(operation: Operation): Operation {
	return JSON.parse(JSON.stringify(operation)) as Operation;
}

function operationHasId(operation: Operation): boolean {
	return typeof operation.id === 'number';
}

function isAddOperation(operation: Operation): boolean {
	return operation.op.startsWith('Add');
}

function remapOperationId(operation: Operation, resolveId: (id: number) => number): Operation {
	if (!operationHasId(operation)) {
		return operation;
	}
	const mapped = cloneOperation(operation);
	mapped.id = resolveId(mapped.id);
	return mapped;
}

export function generateClientId(): string {
	return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

export function generateClientColor(): string {
	const colors = [
		'#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
		'#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52BE80'
	];
	return colors[Math.floor(Math.random() * colors.length)];
}

export function generateClientName(): string {
	const adjectives = ['Swift', 'Bold', 'Creative', 'Bright', 'Sharp', 'Smooth', 'Quick', 'Calm'];
	const nouns = ['Designer', 'Artist', 'Creator', 'Maker', 'Builder', 'Editor', 'Draftsman', 'Illustrator'];
	const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
	const noun = nouns[Math.floor(Math.random() * nouns.length)];
	return `${adj} ${noun}`;
}

export async function createSession(): Promise<SessionInfo> {
	try {
		const response = await fetch(`${API_URL}/api/sessions`, {
			method: 'GET',
		});
		if (!response.ok) {
			throw new Error('Failed to create session');
		}
		const data = await response.json();
		return data as SessionInfo;
	} catch (error) {
		console.error('Error creating session:', error);
		throw error;
	}
}

export async function checkSessionExists(sessionId: string, token: string): Promise<boolean> {
	try {
		const response = await fetch(`${API_URL}/api/sessions/${sessionId}?token=${encodeURIComponent(token)}`);
		if (!response.ok) {
			return false;
		}
		const data = await response.json();
		return Boolean(data.exists && data.token_valid);
	} catch (error) {
		console.error('Error checking session:', error);
		return false;
	}
}

export function connectToSession(
	sessionId: string,
	clientId: string,
	name: string,
	color: string,
	editorApi: EditorApi,
	token: string,
	role: 'editor' | 'viewer' = 'editor',
	onUpdate?: (operation: Operation) => void
): Promise<void> {
	return new Promise((resolve, reject) => {
		if (ws && ws.readyState === WebSocket.OPEN) {
			ws.close();
		}
		resetRealtimeSyncState();

		const wsUrl = `${WS_URL}/ws/${sessionId}?token=${encodeURIComponent(token)}&role=${encodeURIComponent(role)}`;
		ws = new WebSocket(wsUrl);
		
		let joined = false;
		let connectionTimeout: NodeJS.Timeout | null = null;

		ws.onopen = () => {
			console.log('WebSocket connected, readyState:', ws?.readyState);
			reconnectAttempts = 0;

			const joinMessage: ClientMessage = {
				type: 'Join',
				client_id: clientId,
				name,
				color,
			};
			console.log('Sending Join message:', joinMessage);
			ws!.send(JSON.stringify(joinMessage));
			
			collaborationState.update(state => ({
				...state,
				sessionId: state.sessionId || sessionId,
				presenceByClient: {},
				role,
			}));
			
			connectionTimeout = setTimeout(() => {
				if (!joined) {
					reject(new Error('WebSocket connection timeout - did not receive Joined message'));
					ws?.close();
				}
			}, 5000);
		};

		ws.onmessage = async (event) => {
			try {
				const message: ServerMessage = JSON.parse(event.data);
				console.log('Received server message:', message.type, message);
				
				if (message.type === 'Joined' && !joined) {
					joined = true;
					if (connectionTimeout) {
						clearTimeout(connectionTimeout);
						connectionTimeout = null;
					}
					resolve();
				}
				
				await handleServerMessage(message, editorApi, onUpdate);
			} catch (error) {
				console.error('Error parsing server message:', error);
			}
		};

		ws.onerror = (error) => {
			console.error('WebSocket error:', error);
			if (connectionTimeout) {
				clearTimeout(connectionTimeout);
				connectionTimeout = null;
			}
			reconnectAttempts++;
			if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
				reconnectTimeout = setTimeout(() => {
					connectToSession(sessionId, clientId, name, color, editorApi, token, role, onUpdate)
						.then(resolve)
						.catch(reject);
				}, RECONNECT_DELAY * reconnectAttempts);
			} else {
				reject(new Error('Failed to connect after multiple attempts'));
			}
		};

		ws.onclose = () => {
			console.log('WebSocket closed');
			if (connectionTimeout) {
				clearTimeout(connectionTimeout);
				connectionTimeout = null;
			}
			collaborationState.update(state => ({
				...state,
				isConnected: false,
				presenceByClient: {},
			}));

			const state = get(collaborationState);
			if (state.sessionId && reconnectAttempts < MAX_RECONNECT_ATTEMPTS && !joined) {
				reconnectAttempts++;
				reconnectTimeout = setTimeout(() => {
					connectToSession(state.sessionId!, clientId, name, color, editorApi, token, role, onUpdate)
						.catch(console.error);
				}, RECONNECT_DELAY * reconnectAttempts);
			}
		};
	});
}

async function processUpdateMessage(
	update: { operation: Operation; client_id: string; source_local_id?: number },
	editorApi: EditorApi,
	onUpdate?: (operation: Operation) => void
) {
	const state = get(collaborationState);
	if (!state.isConnected) {
		return;
	}

	if (update.client_id === state.clientId) {
		if (
			isAddOperation(update.operation) &&
			typeof update.source_local_id === 'number' &&
			typeof update.operation.id === 'number'
		) {
			registerIdMapping(update.source_local_id, update.operation.id);
		}
		return;
	}

	const incomingServerId = typeof update.operation.id === 'number' ? update.operation.id : null;
	if (isAddOperation(update.operation) && incomingServerId !== null && serverToLocalId.has(incomingServerId)) {
		return;
	}

	const localOperation = remapOperationId(update.operation, resolveIncomingId);
	const appliedId = await applyOperation(localOperation, editorApi);
	if (isAddOperation(update.operation) && incomingServerId !== null && typeof appliedId === 'number') {
		registerIdMapping(appliedId, incomingServerId);
	}
	await tick();
	if (onUpdate) {
		onUpdate(localOperation);
	}
}

async function flushPendingUpdates(editorApi: EditorApi, onUpdate?: (operation: Operation) => void) {
	while (pendingUpdates.has(lastAppliedSeq + 1)) {
		const nextSeq = lastAppliedSeq + 1;
		const next = pendingUpdates.get(nextSeq);
		if (!next) break;
		pendingUpdates.delete(nextSeq);
		await processUpdateMessage(next, editorApi, onUpdate);
		lastAppliedSeq = nextSeq;
	}
}

async function handleServerMessage(
	message: ServerMessage,
	editorApi: EditorApi,
	onUpdate?: (operation: Operation) => void
) {
	switch (message.type) {
		case 'Joined':
			if (message.client_id && message.clients && message.document !== undefined) {
				const currentState = get(collaborationState);
				if (currentState.clientId && currentState.clientId !== message.client_id) {
					console.log('Ignoring Joined message intended for another client:', message.client_id);
					break;
				}

				console.log('Joined session, client_id:', message.client_id, 'isConnected: true');
				lastAppliedSeq = 0;
				pendingUpdates.clear();
				collaborationState.update(state => ({
					...state,
					isConnected: true,
					clientId: state.clientId || message.client_id!,
					collaborators: message.clients!,
					presenceByClient: {},
				}));

				if (message.document !== undefined) {
					editorApi.deserialize(message.document);
					updateStores();
					await tick();
					renderTrigger.update(n => n + 1);
				}

				while (operationQueue.length > 0) {
					const queuedOp = operationQueue.shift();
					if (queuedOp) {
						sendOperation(queuedOp);
					}
				}
			} else {
				console.warn('Joined message missing required fields:', message);
			}
			break;

		case 'ClientJoined':
			if (message.client) {
				collaborationState.update(state => {
					const existingIds = new Set(state.collaborators.map(c => c.id));
					if (existingIds.has(message.client!.id)) {
						return state;
					}
					return {
						...state,
						collaborators: [...state.collaborators, message.client!],
					};
				});
			}
			break;

		case 'ClientLeft':
			if (message.client_id) {
				collaborationState.update(state => ({
					...state,
					collaborators: state.collaborators.filter(c => c.id !== message.client_id),
					presenceByClient: Object.fromEntries(
						Object.entries(state.presenceByClient).filter(([id]) => id !== message.client_id)
					),
				}));
			}
			break;

		case 'Update':
			if (message.operation && message.client_id && typeof message.seq === 'number') {
				if (message.seq <= lastAppliedSeq) break;

				if (message.operation.op === 'FullSync') {
					await applyOperation(message.operation, editorApi);
					pendingUpdates.clear();
					lastAppliedSeq = message.seq;
					break;
				}

				pendingUpdates.set(message.seq, {
					operation: message.operation,
					client_id: message.client_id,
					source_local_id: message.source_local_id,
				});
				await flushPendingUpdates(editorApi, onUpdate);
			} else {
				console.warn('Update message missing required fields:', message);
			}
			break;

		case 'Presence':
			if (message.client_id) {
				const state = get(collaborationState);
				if (message.client_id !== state.clientId) {
					const mappedSelectedIds = (message.selected_ids ?? []).map((id) => resolveIncomingId(id));
					collaborationState.update((current) => ({
						...current,
						presenceByClient: {
							...current.presenceByClient,
							[message.client_id!]: {
								cursor: message.cursor ?? null,
								selectedIds: mappedSelectedIds,
								updatedAt: Date.now(),
							},
						},
					}));
				}
			}
			break;

		case 'Error':
			console.error('Server error:', message.message);
			break;

		case 'Pong':
			break;
	}
}

async function applyOperation(operation: Operation, editorApi: EditorApi): Promise<number | null> {
	const op = operation.op;
	
	try {
		let createdId: number | null = null;
		switch (op) {
			case 'AddRectangle':
				createdId = Number(editorApi.add_rectangle_without_snapshot(
					operation.position.x,
					operation.position.y,
					operation.width,
					operation.height
				));
				break;
			case 'MoveRectangle':
				editorApi.move_rectangle(BigInt(operation.id), operation.position.x, operation.position.y, false);
				break;
			case 'ResizeRectangle':
				editorApi.resize_rectangle(BigInt(operation.id), operation.width, operation.height, false);
				break;
			case 'DeleteRectangle':
				editorApi.delete_rectangle_without_snapshot(BigInt(operation.id));
				break;
			case 'AddEllipse':
				createdId = Number(editorApi.add_ellipse_without_snapshot(
					operation.position.x,
					operation.position.y,
					operation.radius_x,
					operation.radius_y
				));
				break;
			case 'MoveEllipse':
				editorApi.move_ellipse(BigInt(operation.id), operation.position.x, operation.position.y, false);
				break;
			case 'ResizeEllipse':
				editorApi.resize_ellipse(BigInt(operation.id), operation.radius_x, operation.radius_y, false);
				break;
			case 'DeleteEllipse':
				editorApi.delete_ellipse_without_snapshot(BigInt(operation.id));
				break;
			case 'AddDiamond':
				createdId = Number(editorApi.add_diamond_without_snapshot(
					operation.position.x,
					operation.position.y,
					operation.width,
					operation.height
				));
				break;
			case 'MoveDiamond':
				editorApi.move_diamond(BigInt(operation.id), operation.position.x, operation.position.y, false);
				break;
			case 'ResizeDiamond':
				editorApi.resize_diamond(BigInt(operation.id), operation.width, operation.height, false);
				break;
			case 'DeleteDiamond':
				editorApi.delete_diamond_without_snapshot(BigInt(operation.id));
				break;
			case 'AddLine':
				createdId = Number(editorApi.add_line_without_snapshot(
					operation.start.x,
					operation.start.y,
					operation.end.x,
					operation.end.y
				));
				break;
			case 'MoveLine':
				editorApi.move_line(
					BigInt(operation.id),
					operation.start.x,
					operation.start.y,
					operation.end.x,
					operation.end.y,
					false
				);
				break;
			case 'DeleteLine':
				editorApi.delete_line_without_snapshot(BigInt(operation.id));
				break;
			case 'AddArrow':
				createdId = Number(editorApi.add_arrow_without_snapshot(
					operation.start.x,
					operation.start.y,
					operation.end.x,
					operation.end.y
				));
				break;
			case 'MoveArrow':
				editorApi.move_arrow(
					BigInt(operation.id),
					operation.start.x,
					operation.start.y,
					operation.end.x,
					operation.end.y,
					false
				);
				break;
			case 'DeleteArrow':
				editorApi.delete_arrow_without_snapshot(BigInt(operation.id));
				break;
			case 'AddPath':
				const pathId = editorApi.add_path_without_snapshot(operation.points);
				const strokeWidth = getStore(defaultStrokeWidth);
				const strokeColor = getStore(defaultStrokeColor);
				editorApi.set_path_line_width(BigInt(pathId), strokeWidth, false);
				editorApi.set_path_stroke_color(BigInt(pathId), strokeColor, false);
				createdId = Number(pathId);
				break;
			case 'MovePath':
				editorApi.move_path(BigInt(operation.id), operation.offset_x, operation.offset_y, false);
				break;
			case 'SetPathPoints':
				const allPaths = editorApi.get_paths() as any[];
				const pathExists = allPaths.some((p: any) => p.id === operation.id);
				if (!pathExists) {
					console.warn('SetPathPoints: Path with id', operation.id, 'does not exist yet. Creating it.');
					const newPathId = editorApi.add_path_without_snapshot(operation.points);
					const strokeWidth = getStore(defaultStrokeWidth);
					const strokeColor = getStore(defaultStrokeColor);
					editorApi.set_path_line_width(BigInt(newPathId), strokeWidth, false);
					editorApi.set_path_stroke_color(BigInt(newPathId), strokeColor, false);
				} else {
					editorApi.set_path_points(BigInt(operation.id), operation.points, false);
				}
				break;
			case 'DeletePath':
				editorApi.delete_path_without_snapshot(BigInt(operation.id));
				break;
			case 'AddImage':
				createdId = Number(editorApi.add_image_without_snapshot(
					operation.position.x,
					operation.position.y,
					operation.width,
					operation.height,
					operation.image_data
				));
				break;
			case 'MoveImage':
				editorApi.move_image(BigInt(operation.id), operation.position.x, operation.position.y, false);
				break;
			case 'ResizeImage':
				editorApi.resize_image(BigInt(operation.id), operation.width, operation.height, false);
				break;
			case 'DeleteImage':
				editorApi.delete_image_without_snapshot(BigInt(operation.id));
				break;
			case 'AddText':
				createdId = Number(editorApi.add_text_without_snapshot(
					operation.position.x,
					operation.position.y,
					operation.width,
					operation.height,
					operation.content
				));
				break;
			case 'MoveText':
				editorApi.move_text(BigInt(operation.id), operation.position.x, operation.position.y, false);
				break;
			case 'ResizeText':
				editorApi.resize_text(BigInt(operation.id), operation.width, operation.height, false);
				break;
			case 'UpdateText':
				editorApi.set_text_content(BigInt(operation.id), operation.content, false);
				break;
			case 'DeleteText':
				editorApi.delete_text_without_snapshot(BigInt(operation.id));
				break;
			case 'SetRectangleStyle':
				if (operation.stroke_color !== undefined) {
					editorApi.set_rectangle_stroke_color(BigInt(operation.id), operation.stroke_color, false);
				}
				if (operation.fill_color !== undefined) {
					editorApi.set_rectangle_fill_color(BigInt(operation.id), operation.fill_color, false);
				}
				if (operation.line_width !== undefined) {
					editorApi.set_rectangle_line_width(BigInt(operation.id), operation.line_width, false);
				}
				if (operation.dash_pattern !== undefined) {
					editorApi.set_rectangle_dash_pattern(BigInt(operation.id), operation.dash_pattern, false);
				}
				if (operation.border_radius !== undefined) {
					editorApi.set_rectangle_border_radius(BigInt(operation.id), operation.border_radius, false);
				}
				if (operation.rotation_angle !== undefined) {
					editorApi.set_rectangle_rotation(BigInt(operation.id), operation.rotation_angle, false);
				}
				break;
			case 'SetEllipseStyle':
				if (operation.stroke_color !== undefined) {
					editorApi.set_ellipse_stroke_color(BigInt(operation.id), operation.stroke_color, false);
				}
				if (operation.fill_color !== undefined) {
					editorApi.set_ellipse_fill_color(BigInt(operation.id), operation.fill_color, false);
				}
				if (operation.line_width !== undefined) {
					editorApi.set_ellipse_line_width(BigInt(operation.id), operation.line_width, false);
				}
				if (operation.dash_pattern !== undefined) {
					editorApi.set_ellipse_dash_pattern(BigInt(operation.id), operation.dash_pattern, false);
				}
				if (operation.rotation_angle !== undefined) {
					editorApi.set_ellipse_rotation(BigInt(operation.id), operation.rotation_angle, false);
				}
				break;
			case 'SetDiamondStyle':
				if (operation.stroke_color !== undefined) {
					editorApi.set_diamond_stroke_color(BigInt(operation.id), operation.stroke_color, false);
				}
				if (operation.fill_color !== undefined) {
					editorApi.set_diamond_fill_color(BigInt(operation.id), operation.fill_color, false);
				}
				if (operation.line_width !== undefined) {
					editorApi.set_diamond_line_width(BigInt(operation.id), operation.line_width, false);
				}
				if (operation.dash_pattern !== undefined) {
					editorApi.set_diamond_dash_pattern(BigInt(operation.id), operation.dash_pattern, false);
				}
				if (operation.border_radius !== undefined) {
					editorApi.set_diamond_border_radius(BigInt(operation.id), operation.border_radius, false);
				}
				if (operation.rotation_angle !== undefined) {
					editorApi.set_diamond_rotation(BigInt(operation.id), operation.rotation_angle, false);
				}
				break;
			case 'SetLineStyle':
				if (operation.stroke_color !== undefined) {
					editorApi.set_line_stroke_color(BigInt(operation.id), operation.stroke_color, false);
				}
				if (operation.line_width !== undefined) {
					editorApi.set_line_line_width(BigInt(operation.id), operation.line_width, false);
				}
				if (operation.dash_pattern !== undefined) {
					editorApi.set_line_dash_pattern(BigInt(operation.id), operation.dash_pattern, false);
				}
				break;
			case 'SetArrowStyle':
				if (operation.stroke_color !== undefined) {
					editorApi.set_arrow_stroke_color(BigInt(operation.id), operation.stroke_color, false);
				}
				if (operation.line_width !== undefined) {
					editorApi.set_arrow_line_width(BigInt(operation.id), operation.line_width, false);
				}
				if (operation.dash_pattern !== undefined) {
					editorApi.set_arrow_dash_pattern(BigInt(operation.id), operation.dash_pattern, false);
				}
				break;
			case 'SetPathStyle':
				if (operation.stroke_color !== undefined) {
					editorApi.set_path_stroke_color(BigInt(operation.id), operation.stroke_color, false);
				}
				if (operation.line_width !== undefined) {
					editorApi.set_path_line_width(BigInt(operation.id), operation.line_width, false);
				}
				if (operation.dash_pattern !== undefined) {
					editorApi.set_path_dash_pattern(BigInt(operation.id), operation.dash_pattern, false);
				}
				if (operation.rotation_angle !== undefined) {
					editorApi.set_path_rotation(BigInt(operation.id), operation.rotation_angle, false);
				}
				break;
			case 'SetImageStyle':
				if (operation.rotation_angle !== undefined) {
					editorApi.set_image_rotation(BigInt(operation.id), operation.rotation_angle, false);
				}
				break;
			case 'SetTextStyle':
				if (operation.color !== undefined) {
					editorApi.set_text_color(BigInt(operation.id), operation.color, false);
				}
				if (operation.font_size !== undefined) {
					editorApi.set_text_font_size(BigInt(operation.id), operation.font_size, false);
				}
				if (operation.font_family !== undefined) {
					editorApi.set_text_font_family(BigInt(operation.id), operation.font_family, false);
				}
				if (operation.font_weight !== undefined) {
					editorApi.set_text_font_weight(BigInt(operation.id), operation.font_weight, false);
				}
				if (operation.text_align !== undefined) {
					editorApi.set_text_text_align(BigInt(operation.id), operation.text_align, false);
				}
				if (operation.rotation_angle !== undefined) {
					editorApi.set_text_rotation(BigInt(operation.id), operation.rotation_angle, false);
				}
				break;
			case 'BringToFront':
				editorApi.bring_shape_to_front(BigInt(operation.id));
				break;
			case 'BringForward':
				editorApi.bring_shape_forward(BigInt(operation.id));
				break;
			case 'SendBackward':
				editorApi.send_shape_backward(BigInt(operation.id));
				break;
			case 'SendToBack':
				editorApi.send_shape_to_back(BigInt(operation.id));
				break;
			case 'SetElementLock':
				editorApi.set_element_locked(BigInt(operation.id), operation.locked, false);
				break;
			case 'FullSync':
				if (operation.data) {
					editorApi.deserialize(operation.data);
				}
				break;
			default:
				console.warn('Unknown operation:', op);
		}

		updateStores();
		await tick();
		renderTrigger.update(n => n + 1);
		return createdId;
	} catch (error) {
		console.error('Error applying operation:', error, operation);
		return null;
	}
}

export function sendOperation(operation: Operation) {
	const state = get(collaborationState);
	if (state.role === 'viewer') {
		return;
	}
	const outgoingOperation = remapOperationId(operation, resolveOutgoingId);
	console.log('sendOperation called:', {
		op: outgoingOperation.op,
		isConnected: state.isConnected,
		clientId: state.clientId,
		wsExists: !!ws,
		readyState: ws?.readyState
	});
	
	if (!state.sessionId) {
		console.warn('Cannot send operation - no session ID');
		return;
	}

	if (ws && ws.readyState === WebSocket.OPEN && state.isConnected && state.clientId) {
		const message: ClientMessage = {
			type: 'Update',
			operation: outgoingOperation,
		};
		try {
			const json = JSON.stringify(message);
			console.log('Sending operation:', outgoingOperation.op, outgoingOperation);
			ws.send(json);
		} catch (error) {
			console.error('Failed to serialize operation:', error, outgoingOperation);
		}
	} else if (state.sessionId) {
		console.log('Queueing operation until connection is ready:', outgoingOperation.op, {
			wsReady: ws?.readyState === WebSocket.OPEN,
			isConnected: state.isConnected,
			hasClientId: !!state.clientId
		});
		operationQueue.push(outgoingOperation);
	} else {
		console.warn('Cannot send operation - not connected:', {
			isConnected: state.isConnected,
			wsExists: !!ws,
			readyState: ws?.readyState,
			clientId: state.clientId
		});
	}
}

function flushPresence() {
	const state = get(collaborationState);
	if (
		!pendingPresencePayload ||
		!ws ||
		ws.readyState !== WebSocket.OPEN ||
		!state.isConnected ||
		!state.clientId
	) {
		return;
	}

	const now = Date.now();
	if (now - lastPresenceSentAt < PRESENCE_THROTTLE_MS) {
		setTimeout(flushPresence, PRESENCE_THROTTLE_MS - (now - lastPresenceSentAt));
		return;
	}

	const payload = pendingPresencePayload;
	pendingPresencePayload = null;
	lastPresenceSentAt = now;

	const signature = JSON.stringify(payload);
	if (signature === lastPresenceSignature) {
		return;
	}
	lastPresenceSignature = signature;

	const message: ClientMessage = {
		type: 'Presence',
		cursor: payload.cursor,
		selected_ids: payload.selected_ids,
	};
	ws.send(JSON.stringify(message));
}

export function sendPresence(cursor: { x: number; y: number } | null, selectedIds: number[]) {
	const state = get(collaborationState);
	if (state.role === 'viewer') {
		return;
	}
	pendingPresencePayload = {
		cursor,
		selected_ids: selectedIds.map((id) => resolveOutgoingId(id)),
	};
	flushPresence();
}

export function isCollaborationActive(): boolean {
	return get(collaborationState).isConnected;
}

export function disconnect() {
	if (ws) {
		ws.close();
		ws = null;
	}
	if (reconnectTimeout) {
		clearTimeout(reconnectTimeout);
		reconnectTimeout = null;
	}
	operationQueue = [];
	resetRealtimeSyncState();
	collaborationState.set({
		isConnected: false,
		sessionId: null,
		clientId: null,
		collaborators: [],
		presenceByClient: {},
		role: 'editor',
		isHost: false,
	});
}
