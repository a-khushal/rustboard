import { collaborationState } from '$lib/stores/collaboration';
import { get } from 'svelte/store';
import { tick } from 'svelte';
import { updateStores } from './editor-sync';
import { get as getStore } from 'svelte/store';
import { defaultStrokeWidth } from '$lib/stores/stroke-width';
import { defaultStrokeColor } from '$lib/stores/stroke-color';
import { renderTrigger } from '$lib/stores/editor';
// @ts-expect-error -- generated by wasm-bindgen
import type { EditorApi } from '../../../pkg/rustboard_wasm';

const WS_URL = import.meta.env.VITE_WS_URL || 'ws://localhost:3001';
const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001';

export interface Operation {
	op: string;
	[id: string]: any;
}

export interface ClientMessage {
	type: 'Join' | 'Update' | 'Ping';
	client_id?: string;
	name?: string;
	color?: string;
	operation?: Operation;
}

export interface ServerMessage {
	type: 'Joined' | 'ClientJoined' | 'ClientLeft' | 'Update' | 'Error' | 'Pong';
	client_id?: string;
	clients?: Array<{ id: string; name: string; color: string }>;
	document?: string;
	operation?: Operation;
	client?: { id: string; name: string; color: string };
	message?: string;
}

let ws: WebSocket | null = null;
let reconnectTimeout: NodeJS.Timeout | null = null;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_DELAY = 1000;
let operationQueue: Operation[] = [];

export function generateClientId(): string {
	return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

export function generateClientColor(): string {
	const colors = [
		'#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
		'#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52BE80'
	];
	return colors[Math.floor(Math.random() * colors.length)];
}

export function generateClientName(): string {
	const adjectives = ['Swift', 'Bold', 'Creative', 'Bright', 'Sharp', 'Smooth', 'Quick', 'Calm'];
	const nouns = ['Designer', 'Artist', 'Creator', 'Maker', 'Builder', 'Editor', 'Draftsman', 'Illustrator'];
	const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
	const noun = nouns[Math.floor(Math.random() * nouns.length)];
	return `${adj} ${noun}`;
}

export async function createSession(): Promise<string> {
	try {
		const response = await fetch(`${API_URL}/api/sessions`, {
			method: 'GET',
		});
		if (!response.ok) {
			throw new Error('Failed to create session');
		}
		const data = await response.json();
		return data.session_id;
	} catch (error) {
		console.error('Error creating session:', error);
		throw error;
	}
}

export async function checkSessionExists(sessionId: string): Promise<boolean> {
	try {
		const response = await fetch(`${API_URL}/api/sessions/${sessionId}`);
		if (!response.ok) {
			return false;
		}
		const data = await response.json();
		return data.exists;
	} catch (error) {
		console.error('Error checking session:', error);
		return false;
	}
}

export function connectToSession(
	sessionId: string,
	clientId: string,
	name: string,
	color: string,
	editorApi: EditorApi,
	onUpdate?: (operation: Operation) => void
): Promise<void> {
	return new Promise((resolve, reject) => {
		if (ws && ws.readyState === WebSocket.OPEN) {
			ws.close();
		}

		const wsUrl = `${WS_URL}/ws/${sessionId}`;
		ws = new WebSocket(wsUrl);
		
		let joined = false;
		let connectionTimeout: NodeJS.Timeout | null = null;

		ws.onopen = () => {
			console.log('WebSocket connected, readyState:', ws?.readyState);
			reconnectAttempts = 0;

			const joinMessage: ClientMessage = {
				type: 'Join',
				client_id: clientId,
				name,
				color,
			};
			console.log('Sending Join message:', joinMessage);
			ws!.send(JSON.stringify(joinMessage));
			
			collaborationState.update(state => ({
				...state,
				sessionId: state.sessionId || sessionId,
			}));
			
			connectionTimeout = setTimeout(() => {
				if (!joined) {
					reject(new Error('WebSocket connection timeout - did not receive Joined message'));
					ws?.close();
				}
			}, 5000);
		};

		ws.onmessage = async (event) => {
			try {
				const message: ServerMessage = JSON.parse(event.data);
				console.log('Received server message:', message.type, message);
				
				if (message.type === 'Joined' && !joined) {
					joined = true;
					if (connectionTimeout) {
						clearTimeout(connectionTimeout);
						connectionTimeout = null;
					}
					resolve();
				}
				
				await handleServerMessage(message, editorApi, onUpdate);
			} catch (error) {
				console.error('Error parsing server message:', error);
			}
		};

		ws.onerror = (error) => {
			console.error('WebSocket error:', error);
			if (connectionTimeout) {
				clearTimeout(connectionTimeout);
				connectionTimeout = null;
			}
			reconnectAttempts++;
			if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
				reconnectTimeout = setTimeout(() => {
					connectToSession(sessionId, clientId, name, color, editorApi, onUpdate)
						.then(resolve)
						.catch(reject);
				}, RECONNECT_DELAY * reconnectAttempts);
			} else {
				reject(new Error('Failed to connect after multiple attempts'));
			}
		};

		ws.onclose = () => {
			console.log('WebSocket closed');
			if (connectionTimeout) {
				clearTimeout(connectionTimeout);
				connectionTimeout = null;
			}
			collaborationState.update(state => ({
				...state,
				isConnected: false,
			}));

			const state = get(collaborationState);
			if (state.sessionId && reconnectAttempts < MAX_RECONNECT_ATTEMPTS && !joined) {
				reconnectAttempts++;
				reconnectTimeout = setTimeout(() => {
					connectToSession(state.sessionId!, clientId, name, color, editorApi, onUpdate)
						.catch(console.error);
				}, RECONNECT_DELAY * reconnectAttempts);
			}
		};
	});
}

async function handleServerMessage(
	message: ServerMessage,
	editorApi: EditorApi,
	onUpdate?: (operation: Operation) => void
) {
	switch (message.type) {
		case 'Joined':
			if (message.client_id && message.clients && message.document !== undefined) {
				const currentState = get(collaborationState);
				if (currentState.clientId && currentState.clientId !== message.client_id) {
					console.log('Ignoring Joined message intended for another client:', message.client_id);
					break;
				}

				console.log('Joined session, client_id:', message.client_id, 'isConnected: true');
				collaborationState.update(state => ({
					...state,
					isConnected: true,
					clientId: state.clientId || message.client_id!,
					collaborators: message.clients!,
				}));

				if (message.document !== undefined) {
					editorApi.deserialize(message.document);
					updateStores();
					await tick();
					renderTrigger.update(n => n + 1);
				}

				while (operationQueue.length > 0) {
					const queuedOp = operationQueue.shift();
					if (queuedOp) {
						sendOperation(queuedOp);
					}
				}
			} else {
				console.warn('Joined message missing required fields:', message);
			}
			break;

		case 'ClientJoined':
			if (message.client) {
				collaborationState.update(state => {
					const existingIds = new Set(state.collaborators.map(c => c.id));
					if (existingIds.has(message.client!.id)) {
						return state;
					}
					return {
						...state,
						collaborators: [...state.collaborators, message.client!],
					};
				});
			}
			break;

		case 'ClientLeft':
			if (message.client_id) {
				collaborationState.update(state => ({
					...state,
					collaborators: state.collaborators.filter(c => c.id !== message.client_id),
				}));
			}
			break;

		case 'Update':
			if (message.operation && message.client_id) {
				const state = get(collaborationState);
				console.log('Update received:', {
					operation: message.operation.op,
					fromClientId: message.client_id,
					myClientId: state.clientId,
					isConnected: state.isConnected,
					willApply: message.client_id !== state.clientId && state.isConnected
				});
				if (state.isConnected && message.client_id !== state.clientId) {
					console.log('Applying remote operation:', message.operation.op);
					applyOperation(message.operation, editorApi);
					await tick();
					if (onUpdate) {
						onUpdate(message.operation);
					}
				} else if (!state.isConnected) {
					console.warn('Received Update but not connected yet, ignoring');
				} else {
					console.log('Ignoring own operation');
				}
			} else {
				console.warn('Update message missing operation or client_id:', message);
			}
			break;

		case 'Error':
			console.error('Server error:', message.message);
			break;

		case 'Pong':
			break;
	}
}

async function applyOperation(operation: Operation, editorApi: EditorApi) {
	const op = operation.op;
	
	try {
		switch (op) {
			case 'AddRectangle':
				editorApi.add_rectangle_without_snapshot(
					operation.position.x,
					operation.position.y,
					operation.width,
					operation.height
				);
				break;
			case 'MoveRectangle':
				editorApi.move_rectangle(BigInt(operation.id), operation.position.x, operation.position.y, false);
				break;
			case 'ResizeRectangle':
				editorApi.resize_rectangle(BigInt(operation.id), operation.width, operation.height, false);
				break;
			case 'DeleteRectangle':
				editorApi.delete_rectangle_without_snapshot(BigInt(operation.id));
				break;
			case 'AddEllipse':
				editorApi.add_ellipse_without_snapshot(
					operation.position.x,
					operation.position.y,
					operation.radius_x,
					operation.radius_y
				);
				break;
			case 'MoveEllipse':
				editorApi.move_ellipse(BigInt(operation.id), operation.position.x, operation.position.y, false);
				break;
			case 'ResizeEllipse':
				editorApi.resize_ellipse(BigInt(operation.id), operation.radius_x, operation.radius_y, false);
				break;
			case 'DeleteEllipse':
				editorApi.delete_ellipse_without_snapshot(BigInt(operation.id));
				break;
			case 'AddDiamond':
				editorApi.add_diamond_without_snapshot(
					operation.position.x,
					operation.position.y,
					operation.width,
					operation.height
				);
				break;
			case 'MoveDiamond':
				editorApi.move_diamond(BigInt(operation.id), operation.position.x, operation.position.y, false);
				break;
			case 'ResizeDiamond':
				editorApi.resize_diamond(BigInt(operation.id), operation.width, operation.height, false);
				break;
			case 'DeleteDiamond':
				editorApi.delete_diamond_without_snapshot(BigInt(operation.id));
				break;
			case 'AddLine':
				editorApi.add_line_without_snapshot(
					operation.start.x,
					operation.start.y,
					operation.end.x,
					operation.end.y
				);
				break;
			case 'MoveLine':
				editorApi.move_line(
					BigInt(operation.id),
					operation.start.x,
					operation.start.y,
					operation.end.x,
					operation.end.y,
					false
				);
				break;
			case 'DeleteLine':
				editorApi.delete_line_without_snapshot(BigInt(operation.id));
				break;
			case 'AddArrow':
				editorApi.add_arrow_without_snapshot(
					operation.start.x,
					operation.start.y,
					operation.end.x,
					operation.end.y
				);
				break;
			case 'MoveArrow':
				editorApi.move_arrow(
					BigInt(operation.id),
					operation.start.x,
					operation.start.y,
					operation.end.x,
					operation.end.y,
					false
				);
				break;
			case 'DeleteArrow':
				editorApi.delete_arrow_without_snapshot(BigInt(operation.id));
				break;
			case 'AddPath':
				const pathId = editorApi.add_path_without_snapshot(operation.points);
				const strokeWidth = getStore(defaultStrokeWidth);
				const strokeColor = getStore(defaultStrokeColor);
				editorApi.set_path_line_width(BigInt(pathId), strokeWidth, false);
				editorApi.set_path_stroke_color(BigInt(pathId), strokeColor, false);
				break;
			case 'MovePath':
				editorApi.move_path(BigInt(operation.id), operation.offset_x, operation.offset_y, false);
				break;
			case 'SetPathPoints':
				const allPaths = editorApi.get_paths() as any[];
				const pathExists = allPaths.some((p: any) => p.id === operation.id);
				if (!pathExists) {
					console.warn('SetPathPoints: Path with id', operation.id, 'does not exist yet. Creating it.');
					const newPathId = editorApi.add_path_without_snapshot(operation.points);
					const strokeWidth = getStore(defaultStrokeWidth);
					const strokeColor = getStore(defaultStrokeColor);
					editorApi.set_path_line_width(BigInt(newPathId), strokeWidth, false);
					editorApi.set_path_stroke_color(BigInt(newPathId), strokeColor, false);
				} else {
					editorApi.set_path_points(BigInt(operation.id), operation.points, false);
				}
				break;
			case 'DeletePath':
				editorApi.delete_path_without_snapshot(BigInt(operation.id));
				break;
			case 'AddImage':
				editorApi.add_image_without_snapshot(
					operation.position.x,
					operation.position.y,
					operation.width,
					operation.height,
					operation.image_data
				);
				break;
			case 'MoveImage':
				editorApi.move_image(BigInt(operation.id), operation.position.x, operation.position.y, false);
				break;
			case 'ResizeImage':
				editorApi.resize_image(BigInt(operation.id), operation.width, operation.height, false);
				break;
			case 'DeleteImage':
				editorApi.delete_image_without_snapshot(BigInt(operation.id));
				break;
			case 'AddText':
				editorApi.add_text_without_snapshot(
					operation.position.x,
					operation.position.y,
					operation.width,
					operation.height,
					operation.content
				);
				break;
			case 'MoveText':
				editorApi.move_text(BigInt(operation.id), operation.position.x, operation.position.y, false);
				break;
			case 'ResizeText':
				editorApi.resize_text(BigInt(operation.id), operation.width, operation.height, false);
				break;
			case 'UpdateText':
				editorApi.set_text_content(BigInt(operation.id), operation.content, false);
				break;
			case 'DeleteText':
				editorApi.delete_text_without_snapshot(BigInt(operation.id));
				break;
			case 'SetRectangleStyle':
				if (operation.stroke_color !== undefined) {
					editorApi.set_rectangle_stroke_color(BigInt(operation.id), operation.stroke_color, false);
				}
				if (operation.fill_color !== undefined) {
					editorApi.set_rectangle_fill_color(BigInt(operation.id), operation.fill_color, false);
				}
				if (operation.line_width !== undefined) {
					editorApi.set_rectangle_line_width(BigInt(operation.id), operation.line_width, false);
				}
				if (operation.dash_pattern !== undefined) {
					editorApi.set_rectangle_dash_pattern(BigInt(operation.id), operation.dash_pattern, false);
				}
				if (operation.border_radius !== undefined) {
					editorApi.set_rectangle_border_radius(BigInt(operation.id), operation.border_radius, false);
				}
				if (operation.rotation_angle !== undefined) {
					editorApi.set_rectangle_rotation(BigInt(operation.id), operation.rotation_angle, false);
				}
				break;
			case 'SetEllipseStyle':
				if (operation.stroke_color !== undefined) {
					editorApi.set_ellipse_stroke_color(BigInt(operation.id), operation.stroke_color, false);
				}
				if (operation.fill_color !== undefined) {
					editorApi.set_ellipse_fill_color(BigInt(operation.id), operation.fill_color, false);
				}
				if (operation.line_width !== undefined) {
					editorApi.set_ellipse_line_width(BigInt(operation.id), operation.line_width, false);
				}
				if (operation.dash_pattern !== undefined) {
					editorApi.set_ellipse_dash_pattern(BigInt(operation.id), operation.dash_pattern, false);
				}
				if (operation.rotation_angle !== undefined) {
					editorApi.set_ellipse_rotation(BigInt(operation.id), operation.rotation_angle, false);
				}
				break;
			case 'SetDiamondStyle':
				if (operation.stroke_color !== undefined) {
					editorApi.set_diamond_stroke_color(BigInt(operation.id), operation.stroke_color, false);
				}
				if (operation.fill_color !== undefined) {
					editorApi.set_diamond_fill_color(BigInt(operation.id), operation.fill_color, false);
				}
				if (operation.line_width !== undefined) {
					editorApi.set_diamond_line_width(BigInt(operation.id), operation.line_width, false);
				}
				if (operation.dash_pattern !== undefined) {
					editorApi.set_diamond_dash_pattern(BigInt(operation.id), operation.dash_pattern, false);
				}
				if (operation.border_radius !== undefined) {
					editorApi.set_diamond_border_radius(BigInt(operation.id), operation.border_radius, false);
				}
				if (operation.rotation_angle !== undefined) {
					editorApi.set_diamond_rotation(BigInt(operation.id), operation.rotation_angle, false);
				}
				break;
			case 'SetLineStyle':
				if (operation.stroke_color !== undefined) {
					editorApi.set_line_stroke_color(BigInt(operation.id), operation.stroke_color, false);
				}
				if (operation.line_width !== undefined) {
					editorApi.set_line_line_width(BigInt(operation.id), operation.line_width, false);
				}
				if (operation.dash_pattern !== undefined) {
					editorApi.set_line_dash_pattern(BigInt(operation.id), operation.dash_pattern, false);
				}
				break;
			case 'SetArrowStyle':
				if (operation.stroke_color !== undefined) {
					editorApi.set_arrow_stroke_color(BigInt(operation.id), operation.stroke_color, false);
				}
				if (operation.line_width !== undefined) {
					editorApi.set_arrow_line_width(BigInt(operation.id), operation.line_width, false);
				}
				if (operation.dash_pattern !== undefined) {
					editorApi.set_arrow_dash_pattern(BigInt(operation.id), operation.dash_pattern, false);
				}
				break;
			case 'SetPathStyle':
				if (operation.stroke_color !== undefined) {
					editorApi.set_path_stroke_color(BigInt(operation.id), operation.stroke_color, false);
				}
				if (operation.line_width !== undefined) {
					editorApi.set_path_line_width(BigInt(operation.id), operation.line_width, false);
				}
				if (operation.dash_pattern !== undefined) {
					(editorApi as any).set_path_dash_pattern(BigInt(operation.id), operation.dash_pattern, false);
				}
				if (operation.rotation_angle !== undefined) {
					editorApi.set_path_rotation(BigInt(operation.id), operation.rotation_angle, false);
				}
				break;
			case 'SetImageStyle':
				if (operation.rotation_angle !== undefined) {
					editorApi.set_image_rotation(BigInt(operation.id), operation.rotation_angle, false);
				}
				break;
			case 'SetTextStyle':
				if (operation.color !== undefined) {
					editorApi.set_text_color(BigInt(operation.id), operation.color, false);
				}
				if (operation.font_size !== undefined) {
					editorApi.set_text_font_size(BigInt(operation.id), operation.font_size, false);
				}
				if (operation.font_family !== undefined) {
					editorApi.set_text_font_family(BigInt(operation.id), operation.font_family, false);
				}
				if (operation.font_weight !== undefined) {
					editorApi.set_text_font_weight(BigInt(operation.id), operation.font_weight, false);
				}
				if (operation.text_align !== undefined) {
					editorApi.set_text_text_align(BigInt(operation.id), operation.text_align, false);
				}
				if (operation.rotation_angle !== undefined) {
					editorApi.set_text_rotation(BigInt(operation.id), operation.rotation_angle, false);
				}
				break;
			case 'FullSync':
				if (operation.data) {
					editorApi.deserialize(operation.data);
				}
				break;
			default:
				console.warn('Unknown operation:', op);
		}

		updateStores();
		await tick();
		renderTrigger.update(n => n + 1);
	} catch (error) {
		console.error('Error applying operation:', error, operation);
	}
}

export function sendOperation(operation: Operation) {
	const state = get(collaborationState);
	console.log('sendOperation called:', {
		op: operation.op,
		isConnected: state.isConnected,
		clientId: state.clientId,
		wsExists: !!ws,
		readyState: ws?.readyState
	});
	
	if (!state.sessionId) {
		console.warn('Cannot send operation - no session ID');
		return;
	}

	if (ws && ws.readyState === WebSocket.OPEN && state.isConnected && state.clientId) {
		const message: ClientMessage = {
			type: 'Update',
			operation,
		};
		try {
			const json = JSON.stringify(message);
			console.log('Sending operation:', operation.op, operation);
			ws.send(json);
		} catch (error) {
			console.error('Failed to serialize operation:', error, operation);
		}
	} else if (state.sessionId) {
		console.log('Queueing operation until connection is ready:', operation.op, {
			wsReady: ws?.readyState === WebSocket.OPEN,
			isConnected: state.isConnected,
			hasClientId: !!state.clientId
		});
		operationQueue.push(operation);
	} else {
		console.warn('Cannot send operation - not connected:', {
			isConnected: state.isConnected,
			wsExists: !!ws,
			readyState: ws?.readyState,
			clientId: state.clientId
		});
	}
}

export function isCollaborationActive(): boolean {
	return get(collaborationState).isConnected;
}

export function disconnect() {
	if (ws) {
		ws.close();
		ws = null;
	}
	if (reconnectTimeout) {
		clearTimeout(reconnectTimeout);
		reconnectTimeout = null;
	}
	operationQueue = [];
	collaborationState.set({
		isConnected: false,
		sessionId: null,
		clientId: null,
		collaborators: [],
		isHost: false,
	});
}
